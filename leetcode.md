
# 219. Contains Duplicate II

##自己的思路
期初思路是用一个 for 循环嵌套一个 for 循环,这样遍历任意相同的两个数字,然后再判断他们的 index 是不是差距在 k 以内.但是O(n)就有问题了,毕竟时间复杂度相当于 n 的平方了,给出了个1-15000的用例一下子没法做了.

之后考虑用刚学会的 HashTable来做这个题目.首先是初始化一个 Dict, 然后每一个 Dict 的 key 对应的是这个 Array 的数值, value 是一个 List 来存储具体的 index. 这样第一次生成好 Dict 则可以提取 values 出来然后看数目是不是超过1个,超过1个的话意味着有重复的数目,再对比他们的 index 是不是在 k 以内.当然还有一些上下界的需要判断,但是总体而言明显比刚才的 O(n*n)要快很多了.

##别人的实现
然后看了一下 C++的实现思路,也是用到了 Map, 但是 key 和 value 都是存放的 Integer.每一次遍历 Arrary 中的数据的时候,会先查看是不是已经有这个 map 存在了,存在的话直接对比 value 的差值是不是在 k 以内,是的话返回 True, 不是的话覆盖掉前一个.因为题目问的是是不是存在,所以不需要整一个 list都保存下来到 Map 的 Value 里面.而且因为 index 的排序插入肯定是从小到大的,所以直接覆盖也肯定保证不会漏掉任意一组 index.

### 用时 1h 21mins


# 189. Rotate Array

##自己的思路

一开始就是想能不能直接把前半段后半段斩掉对换..后来想了一下感觉还挺麻烦的.

于是直接把原数组乘以2,这样这个新的 List 中间就包含了正确答案,只需要把全半段和后半段根据 k 去掉就是正确答案了.

##别人的思路

解题方法挺多的,关键的一点是这个题目要求的是在原内存内实现,所以直接 nums = nums 的话会分配到新的地方了,所以应该要写成 nums[:] = nums *2, 带上这个[:]才能使得分配的位置在原内存...思路没什么问题倒是卡在了这个 Python 语法上了...有点想切换到 C 做的,但是太久没碰倒也是不会 C 了...

### 用时大概在30分钟内吧


# 169. Majority Element

##自己的思路

一开始当然是想用 Python 自带的方法 count 去统计每一个出现的次数,这样只要判断每个出现的次数是不是大于 n/2就能直接输出了,但是给出的用例是超级多1,然后后半截超级多2,目测输出的应该是2,然后提示超时了...显然直接 for 遍历每个 element 然后再用 List.count()不太适合.

于是就改成了用 Dict, 先把每一个都放进去 Dict, 然后遍历一遍 Dict 看看哪个出现的次数多过 n 就好了.显然这个时间复杂度要远远低于刚才遍历...可能是因为 count 的实现效率很低吧,但是 Dict 遍历一次数组然后最好应该就是 O(n),然后最差可能就是还得全部查一遍到最后就是 O(2n),反正怎样都比 Count 实现要快.
话说回来判断丢进去 Dict 的 value 的时候还是要丢进去判断一下原来是不是为空,这样才能原来的 value 基础上++还是直接初始化为1,这个方法存在还是有他的必要性的...记得刚开始做的话有过这个问题,如果要先加呢还得看是不是存在,但是不访问他就不知道是不是存在...其实就是一个 isExisted 就能解决的问题...


# 121. Best Time to Buy and Sell Stock

##初始的思路

一开始知道这是 DP 的题目,就去 CC189那里看了一下 DP 一般都是什么意思.简而言之就是把之前算过的也就不算了...于是我初始的思路是,无论到了哪一个,我都应该保存下来之前最大的 profit. 但是错就错在于我打算用一个 List 保存其中一个最大值,因为我觉得只要把之前的大那我只需要把现在的数值减去之前的最大值,就能加上 profit 得到新的 profit.求数值最不应该就是相互依赖,更何况这种题目并不需要把之前的计算过程都算清楚,其实只需要理清好思路就可以了.

##改正的思路

把代码全删了,首先加入判断 len(prices)是不是等于1或者0.
然后核心是应该保存之前遍历过的最小值,这样因为我后面陆续输进来的数字我只需要求和最小差的差值,即 profit, 然后对比一下之前保存过的最大 profit 我就能知道要不要更新 profit 或者更新最小值.对比一开始的思路还要两个数组真的是想太多了...重新写2分钟就 AC 了.还是不要把问题复杂化,一步步分解才能做出来 easy 的题目.

# 119. Pascal's Triangle II

##初始思路

一开始并不知道Pascal's Triangle是什么,..还得查一下是什么定义...核心关键在于每一个数字怎么表达...看了一下公式是 n!/(r!*(n-r)!) 然后自然就是每一个丢进去顺便在 返回的List里面做一个 append 就好了... 不知道自己看能不能看得出这个求解的公式..能否脑补出来

# 118. Pascal's Triangle

##初始思路

直接在119的基础上开始改,之前是输出每一行,现在只需要加一个 for 循环把之前的都输出一遍好了.得注意一下下标的变化,毕竟是在之前的基础上来修改的.

# 88. Merge Sorted Array

## 初始思路

for 循环嵌套2个 List, 然后用两个 index 记录下来分别在哪个位置上,然后 insert 进去...但是太复杂,做了一个下午都老是有各种小的问题...我觉得核心问题在于 index 要用的话,你不断 insert 进去就会影响这个 index 到底是多少,就把问题复杂化了.

##改正的思路

直接用2个 for 循环遍历,只要在 nums2的数值提取出来,就和 nums1的所有进行对比,小的就塞进去,大的就直接不管继续..一直到找到位置就用 break 跳出循环.这样因为核心算法是只要小于就插入,所以哪怕 nums1一直因为有 insert 所有数目在变动,但是还是因为基本的算法不变,所以不需要增加 if 语句或者其他条件.另外因为 nums1在增加所以for 循环的 range 应该是 len(nums1)才保证了不会越界之类的问题. 当然还有一个问题就是,无论什么题,都要先写好0,1之类的情况,总有那么几个奇葩案例要考考你...在原数组编辑用好 append,insert 和[:]大概就足够了


# 66. Plus One

if条件比较多,因为最后一位是9的话要判断,不是9也要判断...还要加个 flag 判断是否进位,进位一次还是因为下一位也是9要继续进位...另外如果全部都是9的话还要加个1在最前面,另外要单独判断一下输入是[]空的情况,还有个位的情况...简而言之如果能覆盖所有情况的话,基本上就能做出来了,..用 Java 不太适合做,因为 Java 应该是固定了 List 的不能改的...所以不太方便?


# 27. Remove Element

两句就写好了,用List 自带的 count 方法把次数找到,然后每次都用 List 的 remove 方法去掉..就取巧的解决了

# 26. Remove Duplicates from Sorted Array

期初是打算用 List 自带的 Count 和 Remove 来做的, 但是太复杂了 直接超时了...
后来改成了遍历一遍数组,如果后一个和前一个重复的话,就 remove 掉,这样时间复杂度就只用 O(n)就做好了,当然如果能不强行在 List 上完成的话,转成 Set 一瞬间就解决了...

# 1. Two Sum

一开始先遍历 List,然后每一次都找 target - num 看是否在 nums 存在,有的话就 return, 没有的话就继续...但是 List 实现的可能效率有点低,所以还是改用 Dict 了.

先是把所有数字都放进去 Dict, 然后判断一下有没有 a + a = 2a 的情况,然后就是正常的根据另一半找,比起 List 里面找的实现效率也高很多,因为 Map 本质上是一个 HashTable 所以时间复杂度应该是 O(1).当然因为是遍历,其实还是 O(n),但肯定比在 List 里面找效率要高.

# 268. Missing Number

一开始用 Python List 的方法比较多,比如先 sort, 再看看是不是[0,1,2,3]输出4,或者空的时候输出[0],或者比较 general 的情况就是[1,2,3]输出[0]之类的...if 写多了还超时...可能是 sort 的问题吧...于是直接删代码重写...

然后打算放进去 Dict, 毕竟是 HAsh Table 应该快一点吧 遍历 List 看看哪个在 Map 的 key 里面没有...感觉本质上没有变化,所以还是超时...

后来想了一下觉得毕竟就是缺一个数字,而且还是大部分连续的..直接小学办法求和减去那个 List 就知道到底缺了哪个了...顺便加个条件筛选一下有时候到底[1,2,3]是输出0还是[0,1,2,3]输出[4]就很快 AC 了,题目啊 又想复杂了= =

# 238. Product of Array Except Self

睡前刷一题.求除了自身的和,一开始没有考虑到0的情况,单纯把乘积算出来了然后每一个除以自身就好.加了判断语句防止除以0之后还是不行...因为还有多个0的情况...那就是直接return [0,0,0,0,...]就好了 单个0就是对应的那个0的位置手动回复其他的乘积就好了.方法简单易懂...不过题目讲了"Solve it without division",这个还是得好好看看别人的思路才行= =


# 229. Majority Element II

就遍历 List 看看出现的次数是不是超过了 len(nums) / 3 , 值得一提的是第一次提交的时候, if 的判断条件是写计算 count, 然后再看看返回的 List 里面是不是已经有那个数字了,就超时了...稍微改一下顺序先看有没有,再计算 count 就可以了.说明一个严肃的问题就是 and 语句判断的话,就和以前好像教程讲过,如果前半句已经是 False 的话,后半句也就直接不用跑了...





